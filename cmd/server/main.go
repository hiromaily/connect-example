package main

import (
	"context"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"time"

	connect "github.com/bufbuild/connect-go"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"

	elizav1 "github.com/hiromaily/connect-example/pkg/gen/eliza/v1"        // generated by protoc-gen-go
	"github.com/hiromaily/connect-example/pkg/gen/eliza/v1/elizav1connect" // generated by protoc-gen-connect-go
	greetv1 "github.com/hiromaily/connect-example/pkg/gen/greet/v1"        // generated by protoc-gen-go
	"github.com/hiromaily/connect-example/pkg/gen/greet/v1/greetv1connect" // generated by protoc-gen-connect-go
)

// Refer to
// https://github.com/bufbuild/connect-demo/blob/3a30d4de07d6ac42110acd4ebf64bb4bf8a62579/main.go

// TODO: move somewhere
type GreetServer struct{}
type ElizaServer struct {
	// The time to sleep between sending responses on a stream
	streamDelay time.Duration
}

// TODO: move somewhere
func (s *GreetServer) Greet(
	ctx context.Context,
	req *connect.Request[greetv1.GreetRequest],
) (*connect.Response[greetv1.GreetResponse], error) {
	log.Println("Request headers: ", req.Header())
	res := connect.NewResponse(&greetv1.GreetResponse{
		Greeting: fmt.Sprintf("Hello, %s!", req.Msg.Name),
	})
	res.Header().Set("Greet-Version", "v1")
	return res, nil
}

// TODO: move somewhere
func (e *ElizaServer) Say(
	ctx context.Context,
	req *connect.Request[elizav1.SayRequest],
) (*connect.Response[elizav1.SayResponse], error) {
	//reply, _ := eliza.Reply(req.Msg.Sentence) // ignore end-of-conversation detection
	reply := fmt.Sprintf("You said, %s!", req.Msg.Sentence)
	return connect.NewResponse(&elizav1.SayResponse{
		Sentence: reply,
	}), nil
}

func (e *ElizaServer) Converse(
	ctx context.Context,
	stream *connect.BidiStream[elizav1.ConverseRequest, elizav1.ConverseResponse],
) error {
	for {
		if err := ctx.Err(); err != nil {
			return err
		}
		request, err := stream.Receive()
		if err != nil && errors.Is(err, io.EOF) {
			return nil
		} else if err != nil {
			return fmt.Errorf("receive request: %w", err)
		}
		//reply, endSession := eliza.Reply(request.Sentence)
		reply := fmt.Sprintf("You said, %s!", request.Sentence)
		if err := stream.Send(&elizav1.ConverseResponse{Sentence: reply}); err != nil {
			return fmt.Errorf("send response: %w", err)
		}
	}
}

func (e *ElizaServer) Introduce(
	ctx context.Context,
	req *connect.Request[elizav1.IntroduceRequest],
	stream *connect.ServerStream[elizav1.IntroduceResponse],
) error {
	name := req.Msg.Name
	if name == "" {
		name = "Anonymous User"
	}
	//intros := eliza.GetIntroResponses(name)
	intros := []string{"Hello", "Goodbye", "How are you"}
	var ticker *time.Ticker
	if e.streamDelay > 0 {
		ticker = time.NewTicker(e.streamDelay)
		defer ticker.Stop()
	}
	for _, resp := range intros {
		if ticker != nil {
			select {
			case <-ctx.Done():
				return ctx.Err()
			case <-ticker.C:
			}
		}
		if err := stream.Send(&elizav1.IntroduceResponse{Sentence: resp}); err != nil {
			return err
		}
	}
	return nil
}

func main() {
	mux := http.NewServeMux()
	createHandlers(mux)

	// serve
	http.ListenAndServe(
		"localhost:8080",
		// h2c protocol is the non-TLS version of HTTP/2
		h2c.NewHandler(mux, &http2.Server{}),
	)
}

func createHandlers(mux *http.ServeMux) {
	// params: path, handler
	mux.Handle(greetv1connect.NewGreetServiceHandler(&GreetServer{}))
	mux.Handle(elizav1connect.NewElizaServiceHandler(&ElizaServer{}))
}
